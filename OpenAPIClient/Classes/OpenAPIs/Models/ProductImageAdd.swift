//
// ProductImageAdd.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ProductImageAdd: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case small = "small"
        case base = "base"
        case additional = "additional"
        case thumbnail = "thumbnail"
    }
    /** Defines product id where the image should be added */
    public var productId: String?
    /** Defines image's name */
    public var imageName: String
    /** Defines image's types that are specified by comma-separated list */
    public var type: ModelType
    /** Defines URL of the image that has to be added */
    public var url: String?
    /** Defines alternative text that has to be attached to the picture */
    public var label: String?
    /** Mime type of image http://en.wikipedia.org/wiki/Internet_media_type. */
    public var mime: String?
    /** Defines imageâ€™s position in the list */
    public var position: Int? = 0
    /** Content(body) encoded in base64 of image file */
    public var content: String?
    /** Defines product's variants specified by variant id */
    public var productVariantId: String?
    /** Defines product's variants ids */
    public var variantIds: String?
    /** Defines product's option values ids */
    public var optionValueIds: String?
    /** Store Id */
    public var storeId: String?
    /** Add product image on specified language id */
    public var langId: String?
    /** Use the latest platform API version */
    public var useLatestApiVersion: Bool? = false

    public init(productId: String? = nil, imageName: String, type: ModelType, url: String? = nil, label: String? = nil, mime: String? = nil, position: Int? = 0, content: String? = nil, productVariantId: String? = nil, variantIds: String? = nil, optionValueIds: String? = nil, storeId: String? = nil, langId: String? = nil, useLatestApiVersion: Bool? = false) {
        self.productId = productId
        self.imageName = imageName
        self.type = type
        self.url = url
        self.label = label
        self.mime = mime
        self.position = position
        self.content = content
        self.productVariantId = productVariantId
        self.variantIds = variantIds
        self.optionValueIds = optionValueIds
        self.storeId = storeId
        self.langId = langId
        self.useLatestApiVersion = useLatestApiVersion
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case productId = "product_id"
        case imageName = "image_name"
        case type
        case url
        case label
        case mime
        case position
        case content
        case productVariantId = "product_variant_id"
        case variantIds = "variant_ids"
        case optionValueIds = "option_value_ids"
        case storeId = "store_id"
        case langId = "lang_id"
        case useLatestApiVersion = "use_latest_api_version"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(productId, forKey: .productId)
        try container.encode(imageName, forKey: .imageName)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(url, forKey: .url)
        try container.encodeIfPresent(label, forKey: .label)
        try container.encodeIfPresent(mime, forKey: .mime)
        try container.encodeIfPresent(position, forKey: .position)
        try container.encodeIfPresent(content, forKey: .content)
        try container.encodeIfPresent(productVariantId, forKey: .productVariantId)
        try container.encodeIfPresent(variantIds, forKey: .variantIds)
        try container.encodeIfPresent(optionValueIds, forKey: .optionValueIds)
        try container.encodeIfPresent(storeId, forKey: .storeId)
        try container.encodeIfPresent(langId, forKey: .langId)
        try container.encodeIfPresent(useLatestApiVersion, forKey: .useLatestApiVersion)
    }
}

